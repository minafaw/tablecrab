# -*- coding: utf-8 -*-

"""x11 specific methods via shell

@dependences: xwininfo
"""
#************************************************************************************
#LICENCE: AGPL
#
# Copyright 2012 JÃ¼rgen Urner (jUrner<at>arcor.de)
#
# This program is free software: you can redistribute it and/or modify it under the
# terms of the GNU Affero General Public License as published by the Free Software
# Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>. In the "official"
# distribution you can find the license in agpl-3.0.txt.
#************************************************************************************

import re, subprocess

__all__ = ['WindowManager', ]

#************************************************************************************
# helpers
#************************************************************************************
# check if X is running
#TODO: check if test if ok
out, err = subprocess.Popen(
		'ps -e | grep X', stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True
		).communicate()
if not ' Xorg' in out:
	raise OSError('no X server running!')

# pattern to match output from xwininfo (warning: not generic, just good enough for our purposes)
PatXWinInfo = re.compile('''
		\s*
		(?P<handle>0x[\dabcdef]+)\s+
		\"(?P<title>.+)\"\:\s+
		\(
			\"(?P<application>.+?)\".*?
		\)\s+
		(?P<w>\d+)x
		(?P<h>\d+)+
		.+?\s
		\+(?P<x>\-?\d+)
		\+(?P<y>\-?\d+)
		''',
		re.X|re.I)

def toplevel_windows():
	"""returns a list of all toplevel windows
	@return: (list) L{Window}s
	@note: we ignore windows here that do not have a name (title)
	"""
	windows = []
	out, err = subprocess.Popen(
		'xwininfo -root -tree', stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True
		).communicate()
	if err:
		raise ValueError(err)
	for line in out.split('\n'):
		if ' (has no name): ' in line:
			continue
		match = PatXWinInfo.match(line)
		if match:
			d = match.groupdict()
			handle = int(d['handle'], 16)
			x = int(d['x'])
			y = int(d['y'])
			w = int(d['w'])
			h = int(d['h'])
			window = Window(handle, unicode(d['title'].decode('utf-8')), d['application'], (x, y, w, h))
			windows.append(window)
	return windows

#************************************************************************************
# window manager implementation
#
#NOTES:
# - windows are not guaranteed to be alive when we handle them
# - we can not guarantee the identity of a window. another window may have been
#   created with the same handle from the same application at any time.
#
# so i found best approach is to retrieve all data for a window on every hop and let
# the user deal with eventual troubles.
#************************************************************************************
class Window(object):
	"""window implementation
	@ivar application: (str) appllication that created the window
	@ivar geometry: (tuple) client area coordinates (x, y, w, h) relative to the screen
	@ivar handle: (int) platform dependend window handle
	@ivar title: (unicode) title of the window
	"""
	def __init__(self, handle, title, application, geometry):
		self.application = application
		self.geometry = geometry
		self.handle = handle
		self.title = title
	def __eq__(self, other):
		return self.handle == other.handle and self.application == other.application
	def __ne__(self, other): return not self.__eq__(other)

class WindowManager(object):
	"""window manager implementation

	run the manager as generator and process the events it returns on L{next}

	@cvar EVENT_IDLE: event generated when there are no new events. param: None
	@cvar EVENT_WINDOW_CREATED: event generated when a window has been created. param: L{Window}
	@cvar EVENT_WINDOW_GEOMETRY_CHANGED: event generated when the geometry of a window has changed. param: L{Window}
	@cvar EVENT_WINDOW_TITLE_CHANGED: event generated when the title of a window has changed. param: L{Window}
	@cvar EVENT_WINDOW_DESTROYED: event generated when a window has been destroyed. param: L{Window}

	@note: L{Window}s passed in events are snapshots of windows not actual windows.
	they are meant for emidiate use. that is, the instances passed are never updated.
	instead	a new instance is passed on every event.
	"""
	EVENT_IDLE = 'idle'
	EVENT_WINDOW_CREATED = 'window-created'
	EVENT_WINDOW_GEOMETRY_CHANGED = 'window-geometry-changed'
	EVENT_WINDOW_TITLE_CHANGED = 'window-title-changed'
	EVENT_WINDOW_DESTROYED = 'window-destroyed'

	def __init__(self):
		"""constructor"""
		self._windows = []

	def __iter__(self):
		"""yes, we are a generator"""
		return self

	def next(self):
		"""returns next event in turn generated by the manager
		@return: (list) of (EVENT_*, param) tuples
		"""
		events = []
		windowsOld = self._windows[:]
		self._windows = toplevel_windows()
		for window in self._windows:
			if window in windowsOld:
				windowOld = windowsOld[windowsOld.index(window)]
				if window.geometry != windowOld.geometry:
					events.append((self.EVENT_WINDOW_GEOMETRY_CHANGED, window))
				if window.title != windowOld.title:
					events.append((self.EVENT_WINDOW_TITLE_CHANGED, window))
			else:
				events.append((self.EVENT_WINDOW_CREATED, window))
				events.append((self.EVENT_WINDOW_GEOMETRY_CHANGED, window))
				events.append((self.EVENT_WINDOW_TITLE_CHANGED, window))
		for window in windowsOld:
			if window not in self._windows:
				events.append((self.EVENT_WINDOW_DESTROYED, window))
		if not events:
			events.append((self.EVENT_IDLE, None))
		return events

	def windows(self):
		"""returns list of L{Window}s currently known to the manager"""
		return self._windows

#************************************************************************************
#
#************************************************************************************
if __name__ == '__main__':
	# sample code + run WindowManager (CAUTION: will run unconditionally until keyboard interrupt!!)
	import time
	wm = WindowManager()
	for events in wm:
		for event, param in events:
			if isinstance(param, Window):
				window = param
				print '%s: 0x%x "%s" ("%s") %s' % (event, window.handle, window.title, window.application, window.geometry)
		time.sleep(0.5)
